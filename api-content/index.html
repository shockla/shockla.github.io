{"posts":[{"title":"计算机图形学 - 流水线基础","content":"本文内容与网上已有的相关资料高度重合，仅作个人记录之用，不具参考价值。 本文的主要参考资料为《Unity Shader入门精要》。 何谓流水线 应用阶段 几何阶段 顶点着色器 ^VertexShader^ 裁剪 ^Clipping^ 坐标空间的变换 模型空间 世界空间 观察空间 裁剪空间 屏幕空间 屏幕映射 ^ScreenSpaceMapping^ 光栅化阶段 ^RasterizerStage^ 三角形设置 ^TriangleSetup^ 三角形遍历 ^TriangleTraversal^ 片元着色器 ^FragmentShader^ 逐片元操作 ^Per-FragmentOperations^ 模板测试 深度测试 混和 何谓流水线 流水线，也译作管线 Pipeline。 流水线就是指CPU和GPU合作完成渲染的一整个流程。 本文的重点在GPU流水线方面。 《Renl-Time Rendering, Third Edition》一书将渲染流程分为三个阶段 Stage ，每个阶段又分为几个子阶段。（2018-8-6出了第四版，日后有空应该看看） 三个主要阶段为： 应用阶段 ApplicationStage 几何阶段GeomrteyStage 光栅化阶段RasterizerStage。 上图中，颜色表示不同阶段的可配置性或可编程性：绿色表示完全可编程控制，黄色表示可配置但不可编程，蓝色完全固定，无法更改。实线表示必须由开发者编程实现，虚线表示该Shader是可选的。 应用阶段 这个过程通常运行在CPU上，由开发者决定具体做什么，开发者对此阶段拥有完整的控制权。 一般来说，这个阶段有三个任务： 把数据加载到显存 设置渲染状态 调用Draw Call[1] 几何阶段 几何阶段，正如其名字所言，主要是一些关于几何的处理工作： 要绘制哪些图元 如何绘制图元 何处绘制图元 几何阶段是逐 图元[2] 处理的。 几何阶段可分为以下几个步骤： 顶点着色器 VertexShader (必须的、重要的、可编程的) 曲面细分着色器 TessellationShader (可选的) 几何着色器 GeometryShader(可选的) 裁剪 Clipping 屏幕映射 ScreenSpaceMapping 其中， 对 曲面细分着色器 和 几何着色器 暂不研究。 顶点着色器 VertexShader 重点关注对象。 顶点着色器是编程的。 一般而言，顶点着色器最基本的任务是将 模型空间 的顶点位置转换到 齐次裁剪空间，然后由硬件做透视除法，得到归一化的设备坐标（Normalized Device Coordinates，NDC）。 这个转换比较复杂，在 #坐标空间的变换 中会细说。 模型空间 --模型变换--&gt; 世界空间 --观察变换--&gt; 观察空间 --投影变换--&gt; 裁剪空间 --屏幕映射--&gt; 屏幕空间 裁剪 Clipping 这一步将不在视野内的顶点裁剪掉，并剔除某些三角图元的面片。 由于场景可能会很大，且摄像机视野范围很可能不会覆盖所有物体，把视野外的物体排除在外，可提升性能表现。 对于完全在视野内的图元，直接传递给下一个阶段。 对于部分在视野内的图元，进行裁剪处理——在线段和视野边界的交点生成新的顶点然后再传递给下一个阶段。 对于完全在视野内外的图元，直接丢弃。 完成裁剪操作后，GPU会使用 透视除法 把 齐次裁剪空间 坐标转换为 NDC 坐标。 坐标空间的变换 模型空间 模型空间（model space），也叫 对象空间 （object space）或 局部空间 （local space） 世界空间 你懂的。 观察空间 通俗地说，以摄像机为原点的坐标系。 需注意的是，Unity中观察空间采用的是 右手坐标系。摄像机的前侧对着z轴负方向，即z坐标越小，深度越大，离摄像机越远。 裁剪空间 屏幕空间 屏幕映射 ScreenSpaceMapping 这个阶段的输入是NDC坐标，任务是把每个图元的x和y坐标转换到 屏幕坐标系 下。 屏幕坐标系 是一个二维坐标系，它与最终画面的分辨率有很大关系。 输入的NDC坐标的z值将会与 屏幕坐标系 一同组成一个新的坐标系，称为 窗口坐标系。 这些值将被输出，用于光栅化阶段。 光栅化阶段 RasterizerStage 此阶段主要在GPU上运行，其任务是依据几何阶段输出的数据决定屏幕上的像素颜色，得到最终图像。 此阶段的主要任务：计算每个图元覆盖了屏幕上的哪些像素，以及这些像素的颜色。 此阶段对集合阶段的结果作插值处理，然后再逐像素处理。 三角形设置 TriangleSetup 此阶段计算光栅化一个三角网格所需要的信息，这句话可能比较空洞，不够具体。 我把它理解为一个中间步骤： 上一阶段的输出是三角网格的顶点合集。 下一阶段的目的是计算一个三角网格覆盖了哪些像素。 本阶段的主要目的是通过顶点信息计算三角网格的边界像素坐标情况，为下一阶段做准备。 三角形遍历 TriangleTraversal 三角形遍历也被称为 扫描变换 ScanConversion。 这一阶段根据上一阶段的计算结果判断一个三角网格覆盖了哪些像素，对于每个被覆盖的像素，都会（通过插值）生成一个片元[3]。 此阶段的输出是一个片元序列。 片元着色器 FragmentShader 重点关注对象。 片元着色器阶段是可编程的。在DirectX中，也叫Pixel Shader。 逐片元操作 Per-FragmentOperations Per-Frag Ops 是 OpenGL 中的说法，在DirectX称之为 Output - Merger。 两个名字各有千秋，我们可将其理解为 Output N Merge (per-fragment)-ly。 人话：逐片元操作 考察每个片元 Fragment 的一些属性能否满足给定的条件，以此对片元进行筛选。能否通过筛选，决定了这个片元能否影响最终图像上对应像素点的颜色。如果一个片元没有通过测试，那么之前为了生成这个片元所做的努力几乎都是无用功。 模板测试 TODO 深度测试 TODO 混和 TODO Draw Call：对于每个要绘制的图元，CPU先准备相关数据，设置好渲染状态，然后调用图形接口 OpenGL/DirectX/Vulkan等 ，命令GPU进行渲染操作。很多时候，性能瓶颈就在Draw Call上。 ↩︎ 图元：通俗地讲，图元可以是点、线、三角面。 ↩︎ 片元：片元还不是真正意义上的像素，而是一个包含了很多状态信息的集合，这些状态信息将被用于计算每个像素的最终颜色（如果能通过所有测试的话）。状态信息包括但不限于：屏幕空间坐标、深度信息、其它从 几何阶段 输出的信息。一个像素可能对应多个片元。 ↩︎ ","link":"https://blog.spwg.online/post/ji-suan-ji-tu-xing-xue-liu-shui-xian-ji-chu/"},{"title":"计算机图形学 - 数学基础","content":" 坐标系basics 笛卡尔坐标系 左手坐标系、右手坐标系 Unity使用的坐标系 矢量 矩阵 矩阵的运算法则 与标量的乘法 与矩阵的乘法 转置 逆矩阵 逆矩阵的性质 正交矩阵 矩阵的几何意义——变换 线性变换与非线性变换 变换矩阵 分解基础变换矩阵 平移 缩放 旋转 复合变换 坐标空间的变换 坐标系basics 笛卡尔坐标系 二维，三维，简单，不谈。 左手坐标系、右手坐标系 👆左手坐标系，left-hand coordinate space TODO：左手法则.svg 左手坐标系中，正向旋转使用左手法则定义。 左手法则：左手握拳，竖起大拇指，大拇指方向所在直线为旋转轴，手指方向为 正向旋转 旋转方向。 如果两个坐标系可以通过旋转的方法使所有的坐标指向重合，那么我们就说，这两个坐标系有相同的旋向性（handedness）。左手坐标系与右手坐标系具有不同的旋向性。 Unity使用的坐标系 观察空间是右手坐标系，除此以外全是左手坐标系。 例： Unity在 模型空间 中使用 左手坐标系。 这意味着： 在模型空间中，一个物体的右侧（right）、上侧（up）、前侧（forward）分别对应了x、y、z轴的正方向。 Unity在 观察空间 中使用 右手坐标系。 这意味着： 在观察空间中，摄像机的前侧（forward）对应着z轴的负方向。 矢量 也称向量。一方通行路过 矢量是指n维空间中，一种包含了 模（magnitude） 和 方向（direction） 的有向线段。 矢量存在的意义更多是为了和 标量（scalar） 区分开，实际上，我们使用相同的结构储存点和矢量。 单位矢量（unit vector），也叫 被归一化的矢量（normalized vector），模长为1的矢量。 把任意非零矢量转换为单位矢量的过程称为 归一化（normalization）。 ##矢量运算 求模，加减乘除，不谈。 点乘和叉乘有很多叫法。 点乘、点积（dot product）、内积（inner product）。 结果类型：标量 几何意义：投影。 常见用途：比较两个矢量的方向。 叉乘，叉积（cross product）、外积（outer product）。 几何意义： 常见用途：求垂直于一个平面、三角形的矢量（如法线等）。 矩阵 Morpheus: Unfortunately, no one can be told what The Matrix is. You'll have to see it for yourself. &lt;The Matrix&gt; 行数与列数相等的矩阵称为 方块矩阵，简称方阵（squate matrix）。Shader中，最常用的就是 3x3 和 4x4 的方阵。 如果一个方阵中除对角元素（diagonal elements）以外的所有元素都为0，那么这个方阵就叫 对角矩阵（diagonal matrix）。 对角矩阵中，对角元素全为1的矩阵叫 单位矩阵（identity matrix）。我们一般用 InI_{n}In​ 表示 单位矩阵。任何矩阵与它相乘的结果都是原来的矩阵。即 MI=IM=M\\boldsymbol{MI} = \\boldsymbol{IM} = \\boldsymbol{M} MI=IM=M 我们可以把矢量视为 nx1 的列矩阵（column matrix）或 1xn 的行矩阵（row matrix）。例如，矢量x⃗=(3,8,6)\\vec{x}= (3,8,6)x=(3,8,6) 可以写成行矩阵 [386]\\begin{bmatrix}3&amp;8&amp;6\\end{bmatrix} [3​8​6​] 或列矩阵 [386]\\begin{bmatrix} 3\\\\ 8\\\\ 6\\\\ \\end{bmatrix}⎣⎡​386​⎦⎤​ 在Unity中，常规做法是把矢量转换成列矩阵，这样就必须放在矩阵右侧参与运算。也就是说，我们的矩阵乘法通常都是右乘，例如： CBAv=(C(B(Av)))\\boldsymbol{CBAv} = (\\boldsymbol{C}(\\boldsymbol{B}(\\boldsymbol{Av}))) CBAv=(C(B(Av))) 如果执意要把矢量转换成行矩阵，那也没人能阻止你。这种情况下，必须放在矩阵左边参与运算。运算如下： vTCTBTAT=(((vTAT)BT)CT)\\boldsymbol{v^TC^TB^TA^T} = \\boldsymbol{(((v^TA^T)B^T)C^T)} vTCTBTAT=(((vTAT)BT)CT) 为什么必须放在左侧或右侧？因为矩阵与矩阵能够相乘的前提是左边矩阵的列数等于右边矩阵的行数。 上面两种运算是等价的。 矩阵的运算法则 与标量的乘法 矩阵可以与标量相乘，矩阵中每个元素和该标量相乘，结果为尺寸相同的矩阵。 kM=Mk=[m11m12m13m21m22m23m31m32m33]=[km11km12km13km21km22km23km31km32km33]k\\boldsymbol{M} = \\boldsymbol{M}k = \\begin{bmatrix} m_{11} &amp; m_{12} &amp; m_{13}\\\\ m_{21} &amp; m_{22} &amp; m_{23}\\\\ m_{31} &amp; m_{32} &amp; m_{33} \\end{bmatrix} = \\begin{bmatrix} km_{11} &amp; km_{12} &amp; km_{13}\\\\ km_{21} &amp; km_{22} &amp; km_{23}\\\\ km_{31} &amp; km_{32} &amp; km_{33} \\end{bmatrix} kM=Mk=⎣⎡​m11​m21​m31​​m12​m22​m32​​m13​m23​m33​​⎦⎤​=⎣⎡​km11​km21​km31​​km12​km22​km32​​km13​km23​km33​​⎦⎤​ 与矩阵的乘法 矩阵可以与矩阵相乘，结果为一个新的矩阵，这个矩阵的维度和两个原矩阵的维度有关。 一个 r *n的矩阵 A 和一个 n * c 的矩阵 B 相乘，他们的结果 AB 将会是一个 r * c的矩阵。 只有当A的列数和B的行数相同时，他们才能相乘。 假设 AB = C ，那么 C 中每一个元素CijC_{ij}Cij​ 的值为 A 第i 行 对应的矢量 和 B 第j 列 对应的矢量进行点乘的结果。 矩阵与矩阵的乘法不满足交换律，通常情况下，AB≠BA\\boldsymbol{AB} \\ne \\boldsymbol{BA}AB​=BA （特殊情况下可以相等） 矩阵之间的乘法满足结合律，即 (AB)C=A(BC)(\\boldsymbol{AB})\\boldsymbol{C} = \\boldsymbol{A} (\\boldsymbol{BC})(AB)C=A(BC) 转置 矩阵还有一种运算叫 转置。 给定一个 rxc 的矩阵 M，它的转置可以表示为MT\\boldsymbol{M}^{T}MT —— 一个 cxr 的矩阵。执行转置操作后，原矩阵的第i行变成第i列，第j列变成第j行。即 MijT=Mji\\boldsymbol{M}_{ij}^{T} = \\boldsymbol{M}_{ji} MijT​=Mji​ 例如： [621037549]T=[672510439]\\begin{bmatrix} 6&amp;2&amp;10&amp;3\\\\ 7&amp;5&amp;4&amp;9 \\end{bmatrix}^{T} = \\begin{bmatrix} 6&amp;7\\\\ 2&amp;5\\\\ 10&amp;4\\\\ 3&amp;9 \\end{bmatrix} [67​25​104​39​]T=⎣⎢⎢⎡​62103​7549​⎦⎥⎥⎤​ 我们可以对之前提到过的矢量矩阵做转置。 逆矩阵 逆矩阵和正交没学过，但它的概念比较重要，这里多花一些篇幅，单独写一节。 给定一个矩阵 M，当我们说另一个矩阵 M-1 是 M 的逆矩阵时，我们称 A 是 B 的 逆矩阵（inverse matrix），反之亦然。 逆矩阵类似标量的倒数，上面的例子中，AB = I（单位矩阵） 不是所有矩阵都有逆矩阵，拥有逆矩阵的前提之一是必须是方阵。 如果一个矩阵有逆矩阵，我们就称这个矩阵是 可逆的（invertible） 或者说是 非奇异的（nonsingular）；反之亦然，如果没有逆矩阵，我们说它是不可逆的（noninvertible）或者说是 奇异的（singular）。 判断一个矩阵是否可逆的方法是计算它的 行列式（determinant）。如果行列式不为零，那么它就是可逆的。 这里不研究如何求一个矩阵的逆矩阵，C++数学库Eigen可以求逆矩阵，Unity中，重要的矩阵提供了对应的逆矩阵常量给我们使用。 逆矩阵的性质 逆矩阵的逆矩阵就是原矩阵本身。 单位矩阵的逆矩阵是它本身。 转置矩阵的逆矩阵是逆矩阵的转置。跟我一起绕口令 (MT)−1=(M−1)T(\\boldsymbol{M}^{T})^{-1} = (\\boldsymbol{M}^{-1})^{T} (MT)−1=(M−1)T 矩阵串接相乘后的逆矩阵等于反向串接各个矩阵的逆矩阵。即：是逻辑代数！ (AB)−1=B−1A−1(\\boldsymbol{AB})^{-1} = \\boldsymbol{B}^{-1}\\boldsymbol{A}^{-1} (AB)−1=B−1A−1 正交矩阵 还有一种特殊的 方阵 是 正交矩阵（orthogonal matrix）。正交是矩阵的一种属性。 如果一个方阵 M和它的转置矩阵的乘积是单位矩阵，我们就说这个矩阵是 正交的（orthogonal）。反之亦然。即： 当我们说矩阵 **M** 是正交的时，我们的意思是：$\\boldsymbol{M}^{T}=\\boldsymbol{M}^{-1}$ 矩阵的几何意义——变换 变换（transform）就是对一些数据（点、矢量、颜色等）通过某种方式进行转换的过程。 线性变换与非线性变换 定义一个变换f(x)，如果f(x)满足 f(x)+f(x)=f(x+y)f(x) + f(x) = f(x+y) f(x)+f(x)=f(x+y) kf(x)=f(kx)kf(x) = f(kx) kf(x)=f(kx) 我们就称这个变换为 线性变换（linear transform）。 常见的线性变换有缩放（scale）、旋转（rotation）、错切（shear）、镜像（mirroring/reflection）、正交投影（orthographic projection）等。 假设我们定义了一个平移变换：f(x)=x⃗+(1,2,3)f(x)=\\vec{x}+(1,2,3)f(x)=x+(1,2,3)。 回到线性变换的定义，代入 x⃗=(1,1,1)\\vec{x} = (1,1,1)x=(1,1,1)，可以得到： f(x)+f(x)=(4,6,8)f(x) + f(x) = (4,6,8) f(x)+f(x)=(4,6,8) f(x+x)=(3,4,5)f( x+x ) = (3,4,5) f(x+x)=(3,4,5) 也就说平移不是线性变换。 但是平移是非常常见的变换，我们希望使用平移变换。 于是就有了 仿射变换（affine transform）。仿射变换就是合并线性变换和平移变换的变换类型。 仿射变换可以使用4x4的矩阵表示，为此，我们需要把矢量扩展到四维空间下，这就是 齐次坐标空间（homogeneous space）。 变换矩阵 分解基础变换矩阵 平移 缩放 旋转 复合变换 我们可以把平移、旋转、缩放组合起来，形成一个复杂的变换过程。 须注意的是，一般情况下，我们按约定的顺序做变换：先缩放，再旋转，最后再平移。 在Unity中，如果同时绕着3个轴进行旋转，将会按照zxy的顺序进行。 坐标空间的变换 每个坐标空间都有一个父坐标空间，对坐标空间的变换，实际上就是在父空间和子空间之间对点和矢量进行变换。 给定两个坐标空间： 父坐标空间 P 子坐标空间 C 给定一个点或矢量B，使用在P中表示为Bp，在C中表示为Bc。 于是我们可以通过转换矩阵来实现Bp和Bc的相互转换： Bp=Mc→pBc\\boldsymbol{B}_{p} = \\boldsymbol{M}_{c \\rightarrow p}\\boldsymbol{B}_{c} Bp​=Mc→p​Bc​ Bc=Mp→cBp\\boldsymbol{B}_{c} = \\boldsymbol{M}_{p \\rightarrow c}\\boldsymbol{B}_{p} Bc​=Mp→c​Bp​ 其中，Mc→p\\boldsymbol{M}_{c \\rightarrow p}Mc→p​和Mp→c\\boldsymbol{M}_{p \\rightarrow c}Mp→c​就是变换矩阵，它们互为逆矩阵。 假设，子坐标空间C的原点在父坐标空间下为Oc，子坐标空间的三个坐标轴在坐标空间下表示为x⃗c、y⃗c、z⃗c\\vec{x}_{c}、\\vec{y}_{c}、\\vec{z}_{c}xc​、y​c​、zc​，Bc的坐标为(a,b,c)(a, b, c)(a,b,c)。 那么，在父坐标空间下，Bp就表示为： B⃗p=O⃗c+ax⃗c+by⃗c+cz⃗c\\boldsymbol{\\vec{B}}_{p} = \\boldsymbol{\\vec{O}}_{c} + a\\boldsymbol{\\vec{x}}_{c} + b\\boldsymbol{\\vec{y}}_{c} + c\\boldsymbol{\\vec{z}}_{c} Bp​=Oc​+axc​+by​c​+czc​ 我们把坐标展开，可以写成： (∗oc*_{oc}∗oc​ 应该写成 ∗oc*_{o_{c}}∗oc​​，但我懒得改了...) B⃗p=O⃗c+ax⃗c+by⃗c+cz⃗c\\boldsymbol{\\vec{B}}_{p} = \\boldsymbol{\\vec{O}}_{c} + a\\boldsymbol{\\vec{x}}_{c} + b\\boldsymbol{\\vec{y}}_{c} + c\\boldsymbol{\\vec{z}}_{c}Bp​=Oc​+axc​+by​c​+czc​ =(xoc,yoc,zoc)+a(xxc,yxc,zxz)+b(xyc,yyc,zyc)+c(xzc,yzc,zzc)= ( x_{oc},y_{oc},z_{oc} ) + a( x_{xc},y_{xc},z_{xz} ) + b( x_{yc},y_{yc},z_{yc} ) + c( x_{zc},y_{zc},z_{zc})=(xoc​,yoc​,zoc​)+a(xxc​,yxc​,zxz​)+b(xyc​,yyc​,zyc​)+c(xzc​,yzc​,zzc​) =(xoc,yoc,zoc)+[xxcxycxzcyxcyycyzczxczyczzc][abc]= ( x_{oc},y_{oc},z_{oc} ) + \\begin{bmatrix} x_{xc}&amp;x_{yc}&amp;x_{zc}\\\\ y_{xc}&amp;y_{yc}&amp;y_{zc}\\\\ z_{xc}&amp;z_{yc}&amp;z_{zc} \\end{bmatrix} \\begin{bmatrix} a\\\\b\\\\c \\end{bmatrix}=(xoc​,yoc​,zoc​)+⎣⎡​xxc​yxc​zxc​​xyc​yyc​zyc​​xzc​yzc​zzc​​⎦⎤​⎣⎡​abc​⎦⎤​ =(xoc,yoc,zoc)+[∣∣∣x⃗cy⃗cz⃗c∣∣∣][abc]= ( x_{oc},y_{oc},z_{oc} ) + \\begin{bmatrix} |&amp;|&amp;|\\\\\\vec{x}_{c}&amp;\\vec{y}_{c}&amp;\\vec{z}_{c}\\\\|&amp;|&amp;| \\end{bmatrix} \\begin{bmatrix} a\\\\b\\\\c \\end{bmatrix}=(xoc​,yoc​,zoc​)+⎣⎡​∣xc​∣​∣y​c​∣​∣zc​∣​⎦⎤​⎣⎡​abc​⎦⎤​ 三维矩阵无法表示平移变换，为了能够表示平移，我们可以把上面的式子扩展到齐次坐标空间中： =(xoc,yoc,zoc,1)+[∣∣∣0x⃗cy⃗cz⃗c0∣∣∣00001][abc1]= ( x_{o_{c}},y_{o_{c}},z_{o_{c}},1 ) + \\begin{bmatrix} |&amp;|&amp;|&amp;0\\\\\\vec{x}_{c}&amp;\\vec{y}_{c}&amp;\\vec{z}_{c}&amp;0\\\\|&amp;|&amp;|&amp;0\\\\0&amp;0&amp;0&amp;1 \\end{bmatrix} \\begin{bmatrix} a\\\\b\\\\c\\\\1 \\end{bmatrix}=(xoc​​,yoc​​,zoc​​,1)+⎣⎢⎢⎡​∣xc​∣0​∣y​c​∣0​∣zc​∣0​0001​⎦⎥⎥⎤​⎣⎢⎢⎡​abc1​⎦⎥⎥⎤​ =[100xoc010yoc001zoc0001][∣∣∣0x⃗cy⃗cz⃗c0∣∣∣00001][abc1]= \\begin{bmatrix} 1&amp;0&amp;0&amp;x_{o_{c}}\\\\0&amp;1&amp;0&amp;y_{o_{c}}\\\\0&amp;0&amp;1&amp;z_{o_{c}}\\\\0&amp;0&amp;0&amp;1 \\end{bmatrix}\\begin{bmatrix} |&amp;|&amp;|&amp;0\\\\\\vec{x}_{c}&amp;\\vec{y}_{c}&amp;\\vec{z}_{c}&amp;0\\\\|&amp;|&amp;|&amp;0\\\\0&amp;0&amp;0&amp;1 \\end{bmatrix} \\begin{bmatrix} a\\\\b\\\\c\\\\1 \\end{bmatrix}=⎣⎢⎢⎡​1000​0100​0010​xoc​​yoc​​zoc​​1​⎦⎥⎥⎤​⎣⎢⎢⎡​∣xc​∣0​∣y​c​∣0​∣zc​∣0​0001​⎦⎥⎥⎤​⎣⎢⎢⎡​abc1​⎦⎥⎥⎤​ =[∣∣∣∣x⃗cy⃗cz⃗cOc∣∣∣∣0001][abc1]= \\begin{bmatrix}|&amp;|&amp;|&amp;|\\\\\\vec{x}_{c}&amp;\\vec{y}_{c}&amp;\\vec{z}_{c}&amp;\\boldsymbol{O}_{c}\\\\|&amp;|&amp;|&amp;|\\\\0&amp;0&amp;0&amp;1 \\end{bmatrix} \\begin{bmatrix} a\\\\b\\\\c\\\\1 \\end{bmatrix}=⎣⎢⎢⎡​∣xc​∣0​∣y​c​∣0​∣zc​∣0​∣Oc​∣1​⎦⎥⎥⎤​⎣⎢⎢⎡​abc1​⎦⎥⎥⎤​ 这样我们就能得出：Mc→p=[∣∣∣∣x⃗cy⃗cz⃗cOc∣∣∣∣0001]\\boldsymbol{M}_{c\\rightarrow p} = \\begin{bmatrix}|&amp;|&amp;|&amp;|\\\\\\vec{x}_{c}&amp;\\vec{y}_{c}&amp;\\vec{z}_{c}&amp;\\boldsymbol{O}_{c}\\\\|&amp;|&amp;|&amp;|\\\\0&amp;0&amp;0&amp;1 \\end{bmatrix}Mc→p​=⎣⎢⎢⎡​∣xc​∣0​∣y​c​∣0​∣zc​∣0​∣Oc​∣1​⎦⎥⎥⎤​ ","link":"https://blog.spwg.online/post/ji-suan-ji-tu-xing-xue-ji-chu-shu-xue/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://blog.spwg.online/post/hello-gridea/"}]}